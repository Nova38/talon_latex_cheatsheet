Command	Result
{ variadic }	{ Insert "...".  }
{ logical and }	{ Insert " \&\& ".  }
{ logical or }	{ Insert " || ".  }
{ state comment }	{ Insert "// ".  }
{ {[}line{]} comment $<$user.text$>$ }	{ Press cmd{-}right. Insert " // ". Insert "$<$text$>$ (formatted with sentence)".  }
{ state (funk | func | fun) }	{ Insert "func ".  }
{ function (Annette | init) {[}over{]} }	{ Insert "func init() \{\textbackslashn".  }
{ function $<$user.text$>$ {[}over{]} }	{ Insert "func ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)". Insert "(".  }
{ method $<$user.text$>$ {[}over{]} }	{ Insert "meth ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state var }	{ Insert "var ".  }
{ variable {[}$<$user.text$>${]} {[}over{]} }	{ Insert "var ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ of type {[}$<$user.text$>${]} {[}over{]} }	{ Insert " ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state break }	{ Insert "break".  }
{ state (chan | channel) }	{ Insert " chan ".  }
{ state go }	{ Insert "go ".  }
{ state if }	{ Insert "if ".  }
{ if $<$user.text$>$ {[}over{]} }	{ Insert "if ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ spawn $<$user.text$>$ {[}over{]} }	{ Insert "go ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state else if }	{ Insert " else if ".  }
{ else if $<$user.text$>$ {[}over{]} }	{ Insert " else if ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state else }	{ Insert " else ".  }
{ else $<$user.text$>$ {[}over{]} }	{ Insert " else \{". Press enter. Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state while }	{ Insert "while ".  }
{ while $<$user.text$>$ {[}over{]} }	{ Insert "while ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state for }	{ Insert "for ".  }
{ for $<$user.text$>$ {[}over{]} }	{ Insert "for ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state for range }	{ Insert "forr ".  }
{ range $<$user.text$>$ {[}over{]} }	{ Insert "forr ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state format }	{ Insert "fmt".  }
{ format $<$user.text$>$ {[}over{]} }	{ Insert "fmt.". Insert "$<$text$>$ (formatted with PUBLIC\_CAMEL\_CASE)".  }
{ state switch }	{ Insert "switch ".  }
{ switch $<$user.text$>$ {[}over{]} }	{ Insert "switch ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state select }	{ Insert "select ".  }
{ state (const | constant) }	{ Insert " const ".  }
{ constant $<$user.text$>$ {[}over{]} }	{ Insert "const ". Insert "$<$text$>$ (formatted with PUBLIC\_CAMEL\_CASE)".  }
{ state case }	{ Insert " case ".  }
{ state default }	{ Insert " default:".  }
{ case $<$user.text$>$ {[}over{]} }	{ Insert "case ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state type }	{ Insert " type ".  }
{ type $<$user.text$>$ {[}over{]} }	{ Insert "type ". Insert "$<$text$>$ (formatted with PUBLIC\_CAMEL\_CASE)".  }
{ state true }	{ Insert " true ".  }
{ state false }	{ Insert " false ".  }
{ state (start | struct | struck) }	{ Insert " struct \{". Press enter.  }
{ (struct | struck) $<$user.text$>$ {[}over{]} }	{ Insert " struct \{". Press enter. Insert "$<$text$>$ (formatted with PUBLIC\_CAMEL\_CASE)".  }
{ {[}state{]} empty interface }	{ Insert " interface\{\} ".  }
{ state interface }	{ Insert " interface \{". Press enter.  }
{ interface $<$user.text$>$ {[}over{]} }	{ Insert " interface \{". Press enter. Insert "$<$text$>$ (formatted with PUBLIC\_CAMEL\_CASE)".  }
{ state string }	{ Insert " string ".  }
{ {[}state{]} (int | integer | ant) }	{ Insert "int".  }
{ state slice }	{ Insert " {[}{]}".  }
{ slice of }	{ Insert "{[}{]}".  }
{ {[}state{]} (no | nil) }	{ Insert "nil".  }
{ state (int | integer | ant) sixty four }	{ Insert " int64 ".  }
{ state tag }	{ Insert `before + after`, leaving cursor between `before` and `after`. Not entirely reliable if `after` contains newlines..  }
{ field tag $<$user.text$>$ {[}over{]} }	{ Insert `before + after`, leaving cursor between `before` and `after`. Not entirely reliable if `after` contains newlines.. Insert "$<$text$>$ (formatted with snake)". Insert " ".  }
{ state return }	{ Insert " return ".  }
{ return $<$user.text$>$ {[}over{]} }	{ Insert "return ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ map of string to string }	{ Insert " map{[}string{]}string ".  }
{ map of $<$user.text$>$ {[}over{]} }	{ Insert "map{[}". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)". Press right.  }
{ receive }	{ Insert " $<${-} ".  }
{ make }	{ Insert "make(".  }
{ loggers {[}$<$user.text$>${]} {[}over{]} }	{ Insert "logrus.". Insert "$<$text$>$ (formatted with PUBLIC\_CAMEL\_CASE)".  }
{ length $<$user.text$>$ {[}over{]} }	{ Insert "len(". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ append $<$user.text$>$ {[}over{]} }	{ Insert "append(". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ state (air | err) }	{ Insert "err".  }
{ error }	{ Insert " err ".  }
{ loop over {[}$<$user.text$>${]} {[}over{]} }	{ Insert "forr ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ item $<$user.text$>$ {[}over{]} }	{ Insert ", ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ value $<$user.text$>$ {[}over{]} }	{ Insert ": ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ address of {[}$<$user.text$>${]} {[}over{]} }	{ Insert "\&". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ pointer to {[}$<$user.text$>${]} {[}over{]} }	{ Insert "*". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
{ swipe {[}$<$user.text$>${]} {[}over{]} }	{ Press right. Insert ", ". Insert "$<$text$>$ (formatted with PRIVATE\_CAMEL\_CASE)".  }
